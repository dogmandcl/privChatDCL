"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rule = {
    meta: {
        fixable: "code",
        type: "layout",
    },
    create: context => {
        let importStatements = [];
        return {
            ImportDeclaration: node => {
                importStatements.push(node);
            },
            "Program:exit": () => {
                const sourceCode = context.getSourceCode();
                const checkForCssImport = (str) => /\.s?css/.test(str);
                const cssImports = importStatements.filter((imp) => checkForCssImport(imp.source.value));
                const lastImport = importStatements[importStatements.length - 1];
                const lastNonCssImport = importStatements.filter((imp) => !checkForCssImport(imp.source.value)).reverse()[0];
                if (!cssImports.length || !lastNonCssImport) {
                    return;
                }
                const lastNonCssImportRange = lastNonCssImport.range;
                const lines = sourceCode.getLines();
                cssImports.forEach((cssImport) => {
                    var _a, _b;
                    const currentLineNumber = (_a = cssImport.source.loc) === null || _a === void 0 ? void 0 : _a.start.line;
                    const lastNonCssImportLineNumber = (_b = lastNonCssImport.source.loc) === null || _b === void 0 ? void 0 : _b.start.line;
                    if (!currentLineNumber || currentLineNumber < 0 || !lastNonCssImportLineNumber) {
                        return;
                    }
                    const currentLineIndex = currentLineNumber - 1;
                    const lineBeforeCssImport = lines[currentLineIndex - 1];
                    const trimmedLineBeforeCssImport = lineBeforeCssImport === null || lineBeforeCssImport === void 0 ? void 0 : lineBeforeCssImport.trim();
                    const isComment = (trimmedLineBeforeCssImport === null || trimmedLineBeforeCssImport === void 0 ? void 0 : trimmedLineBeforeCssImport.startsWith("//")) || (trimmedLineBeforeCssImport === null || trimmedLineBeforeCssImport === void 0 ? void 0 : trimmedLineBeforeCssImport.startsWith("/*")) || (trimmedLineBeforeCssImport === null || trimmedLineBeforeCssImport === void 0 ? void 0 : trimmedLineBeforeCssImport.startsWith("*/"));
                    const lineBeforeCssImportWithoutComment = isComment ? lines[currentLineIndex - 2] : lineBeforeCssImport;
                    // if this is the first line isLineBeforeCssImportEmpty should be false
                    const isLineBeforeCssImportEmpty = lineBeforeCssImportWithoutComment != undefined ? /^\s*$/g.test(lineBeforeCssImportWithoutComment) : false;
                    const isLineBeforeCssImportIsCssImport = lineBeforeCssImportWithoutComment && checkForCssImport(lineBeforeCssImportWithoutComment);
                    // if the css import is below the last non css import and there's a blank line or other css import above - do nothing
                    if (currentLineNumber > lastNonCssImportLineNumber && (isLineBeforeCssImportEmpty || isLineBeforeCssImportIsCssImport)) {
                        return;
                    }
                    // if the line before css import is the last non css import
                    if (lineBeforeCssImportWithoutComment && sourceCode.text.slice(...lastNonCssImportRange).includes(lineBeforeCssImportWithoutComment)) {
                        const comments = sourceCode.getCommentsBefore(cssImport);
                        return context.report({
                            node: cssImport,
                            message: "Expected a new line before the css import statement",
                            fix(fixer) {
                                var _a;
                                return fixer.insertTextBefore((_a = comments[0]) !== null && _a !== void 0 ? _a : cssImport, "\n");
                            },
                        });
                    }
                    const cssImportRange = cssImport.range;
                    const isLastImportIsCssImport = checkForCssImport(lastImport.source.value);
                    // do not add a blank line before if there's a group of the css imports
                    const padding = isLastImportIsCssImport ? "\n" : "\n\n";
                    const cssImportCode = padding + sourceCode.text.slice(...cssImportRange);
                    const oldCssImportRange = (() => {
                        // if the first line
                        if (currentLineIndex === 0) {
                            // remove with the \n in the end of line
                            return [0, cssImportRange[1] + 1];
                        }
                        // if there's an empty line before
                        if (isLineBeforeCssImportEmpty) {
                            // remove with the \n\n before the line
                            return [cssImportRange[0] - 2, cssImportRange[1]];
                        }
                        // other cases
                        // remove with the \n before the line
                        return [cssImportRange[0] - 1, cssImportRange[1]];
                    })();
                    // if the css import is not the last one - remove the old css and append the new one after the last import
                    context.report({
                        node: cssImport,
                        message: "Expected the css import statement to be in the end of the import block",
                        fix(fixer) {
                            return [
                                // append css import after the last import
                                fixer.insertTextAfter(lastImport, cssImportCode),
                                // stripe out css import from previous place
                                fixer.replaceTextRange(oldCssImportRange, ""),
                            ];
                        },
                    });
                });
                importStatements = [];
            },
        };
    },
};
exports.default = rule;
//# sourceMappingURL=css-import-order.js.map